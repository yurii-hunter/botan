module Botan.Web.Hash

open Botan.Web.Domain
open System
open System.Security.Cryptography

module Crypto =
    let private subkeyLength = 32
    let private saltSize = 16

    /// Hashes a password by a specified number of iterations using the PBKDF2 crypto function.
    let hash password iterations =
        use algo = new Rfc2898DeriveBytes(Password.value password, saltSize, iterations)
        let salt = algo.Salt
        let bytes = algo.GetBytes(subkeyLength)

        let iters =
            if BitConverter.IsLittleEndian then
                BitConverter.GetBytes(iterations)
            else
                BitConverter.GetBytes(iterations) |> Array.rev

        let parts = Array.zeroCreate<byte> 54
        Buffer.BlockCopy(salt, 0, parts, 1, saltSize)
        Buffer.BlockCopy(bytes, 0, parts, 17, subkeyLength)
        Buffer.BlockCopy(iters, 0, parts, 50, sizeof<int>)

        Convert.ToBase64String(parts)

    let strongHash password = hash password 100_000

    /// Verifies a PBKDF2 hashed password with a candidate password.
    /// Returns true if the candidate password is correct.
    /// The hashed password must have been originally generated by one of the hash functions within this module.
    let verify (hashedPassword: HashedPassword) (password: Password) =
        let parts = Convert.FromBase64String(HashedPassword.value hashedPassword)

        if parts.Length <> 54 || parts.[0] <> byte 0 then
            false
        else
            let salt = Array.zeroCreate<byte> saltSize
            Buffer.BlockCopy(parts, 1, salt, 0, saltSize)

            let bytes = Array.zeroCreate<byte> subkeyLength
            Buffer.BlockCopy(parts, 17, bytes, 0, subkeyLength)

            let iters = Array.zeroCreate<byte> sizeof<int>
            Buffer.BlockCopy(parts, 50, iters, 0, sizeof<int>)

            let iters =
                if BitConverter.IsLittleEndian then
                    iters
                else
                    iters |> Array.rev

            let iterations = BitConverter.ToInt32(iters, 0)

            use algo = new Rfc2898DeriveBytes(Password.value password, salt, iterations)
            let challengeBytes = algo.GetBytes(subkeyLength)

            match Seq.compareWith (fun a b -> if a = b then 0 else 1) bytes challengeBytes with
            | v when v = 0 -> true
            | _ -> false
